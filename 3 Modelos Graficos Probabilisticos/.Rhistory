# No hay que normalizar los datos ya que la distancia de Mahalanobis est?
# dise?ada, precisamente para evitar el problema de la escala.
# uni.plot genera el gr?fico similar a MiPlot_Univariate_Outliers con todas las columnas
# Adem?s, devuelve en $outliers los ?ndices de los outliers
# Establecemos los valores de significaci?n
# alpha.value.penalizado es para tener en cuenta el error FWER
alpha.value = 0.05
alpha.value.penalizado = 1 - ( 1 - alpha.value) ^ (1 / nrow(mydata.numeric))       # Transparencia 91
# Establecemos la semilla para el m?todo iterativo que calcula MCD
set.seed(12)
# Llamamos a uni.plot del paquete mvoutlier con symb=FALSE, alpha = alpha.value.penalizado
# Guardamos el resultado en la variable mvoutlier.plot
# Esta funci?n calcula los outliers MULTIVARIANTES seg?n la distancia de Mahalanobis
# considerando la estimaci?n robusta de la matriz de covarianzas -MCD- y la estimaci?n robusta de la media de cada variable.
# Tambi?n imprime un plot 1-dimensional para ver los valores que toman los outliers en cada atributo
# pero el plot no imprime las etiquetas de los outliers
# Nota: Es posible que haya que instalar el paquete pcaPP para que se pueda ejecutar uni.plot
X11()
# COMPLETAR
mvoutlier.plot <- uni.plot(mydata.numeric,symb=FALSE,alpha = alpha.value.penalizado)
is.MCD.outlier <- mvoutlier.plot$outliers
is.MCD.outlier
numero.de.outliers.MCD <- sum(is.MCD.outlier)
numero.de.outliers.MCD
data.frame.solo.outliers <- mydata.numeric.scaled[is.MCD.outlier]
data.frame.solo.outliers
data.frame.solo.outliers <- mydata.numeric.scaled[is.MCD.outlier,]
data.frame.solo.outliers
MiBoxPlot_juntos(mydata.numeric,is.MCD.outlier)
MiBiPlot_Multivariate_Outliers(mydata.numeric,is.MCD.outlier,"Titulo")
MiPlot_Univariate_Outliers(mydata.numeric,is.MCD.outlier,"Titulo")
indices.de.interes <- which(rownames(mydata.numeric) == "Ferrari Dino")
MiPlot_Univariate_Outliers(mydata.numeric,indices.de.interes,"Titulo")
indices.de.interes
data.frame.solo.outliers
# Apéndice glm
library(rgl)
#' @param new.device a logical value. If TRUE, creates a new device
#' @param bg the background color of the device
#' @param width the width of the device
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) {
if( new.device | rgl.cur() == 0 ) {
rgl.open()
par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
library(rgl)
#' @param new.device a logical value. If TRUE, creates a new device
#' @param bg the background color of the device
#' @param width the width of the device
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) {
if( new.device | rgl.cur() == 0 ) {
rgl.open()
par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
if(show.bbox){
rgl.bbox(color=c(bbox.col[1],bbox.col[2]), alpha = 0.5,
emission=bbox.col[1], specular=bbox.col[1], shininess=5,
xlen = 3, ylen = 3, zlen = 3)
}
}
# Ejemplo que ilustra el modelo de clasificación usando una variable
ç
library(rgl)
#' @param new.device a logical value. If TRUE, creates a new device
#' @param bg the background color of the device
#' @param width the width of the device
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) {
if( new.device | rgl.cur() == 0 ) {
rgl.open()
par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
if(show.bbox){
rgl.bbox(color=c(bbox.col[1],bbox.col[2]), alpha = 0.5,
emission=bbox.col[1], specular=bbox.col[1], shininess=5,
xlen = 3, ylen = 3, zlen = 3)
}
}
# Ejemplo que ilustra el modelo de clasificación usando una variable
datos <-data.frame(y=as.numeric(as.numeric(iris$Species)),
x4=iris$Sepal.Width,
x1=iris$Sepal.Length,
x2=iris$Petal.Length,
x3=iris$Petal.Width)
library(splines)
model3 <- glm(y~ns(x2,16), data =datos)
b <- predict(model3, datos)
rb <- round(b)
x <- seq(1,7,0.01)
x <- rbind(x2=x,y=0)
x <-t(x)
x <-as.data.frame(x)
xy <- predict(model3, newdata = x)
rxy <-round(xy)
plot(datos$x2, datos$y, col = datos$y, xlab = "Longitud del Sépalo", ylab = "Tipo de Iris", title("Specie ~ ns(Petal.Length,16)"))
lines(x[,1],xy,col=ifelse(xy<=1.5, "black", ifelse(xy<=2.5, "red", "green")))
segments(datos$x2,datos$y,datos$x2,b, col=datos$y, lty=4)
abline(2.5,0,col="green")
abline(1.5,0,col="red")
# Ejemplo que ilustra el modelo de clasificación en base a 2 variables
model3 <- glm(y~ns(x2,16)+ns(x1,16), data =datos)
c <- predict(model3, newdata = datos)
plot(datos$x2,datos$x1,col=round(c),pch=0,
xlab = "Longitud del Sépalo", ylab = "Longitud del Pétalo", title("Specie ~ ns(Petal.Length,16)+ns(Sepal.Length,16)"))
points(datos$x2,datos$x1,col=datos$y,pch="x")
#### Ilustrar como se distribuye los espacios de clasificación
plantilla <-matrix(c(0,0,0),ncol=3)
for (p1 in seq(1,8,0.05))
for (p2 in seq(1,7,0.05))
plantilla <-rbind(plantilla, c(x1=p1,x2=p2,y=0))
plantilla <- as.data.frame(plantilla)
plantilla[,3] <- predict(model3, newdata = plantilla)
plot(datos$x2,datos$x1,col=round(c),pch=0,
xlab = "Longitud del Sépalo", ylab = "Longitud del Pétalo", title("Specie ~ ns(Petal.Length,16)+ns(Sepal.Length,16)"))
points(plantilla$x2,plantilla$x1,
col= ifelse(round(plantilla$y)<1, 0, ifelse(round(plantilla$y)>3, 0, round(plantilla$y) )),pch=20)
points(datos$x2,datos$x1,col=round(c),pch=0)
points(datos$x2,datos$x1,col=datos$y,pch="x")
# Ejemplo que ilustra el modelo de clasificación en base a 3 variables
model3 <- glm(y~ns(x2,16)+ns(x1,16)+ns(x3,16), data =datos)
c <- predict(model3, newdata = datos)
plantilla <-matrix(c(0,0,0,0),ncol=4)
for (p1 in seq(1,8,(8-1)/10))
for (p2 in seq(1,7,(7-1)/10))
for (p3 in seq(0, 2.5, 2.5/10 ))
plantilla <-rbind(plantilla, c(x1=p1,x2=p2,x3=p3,y=0))
plantilla <- as.data.frame(plantilla)
plantilla[,4] <- round(predict(model3, newdata = plantilla))
plantilla[,4] <- ifelse(plantilla[,4]<1,"white", ifelse(plantilla[,4]>3,"white",plantilla[,4]))
#saca la grafica en 3d
library(rgl)
rgl_init()
rgl.spheres(x=datos$x2, y=datos$x1, z=datos$x3, r=0.1, col=datos$y)
rgl_add_axes(x=datos$x2, y=datos$x1, z=datos$x3, show.bbox = T)
aspect3d(1,1,1)
#### Ilustra como se distribuyen los espacios de clasificación
rgl_init()
rgl.spheres(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], r=0.1, col=plantilla[,4])
#rgl_add_axes(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], show.bbox = T)
aspect3d(1,1,1)
plot3d(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], col=plantilla[,4])
rgl_init()
rgl.spheres(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], r=0.1, col=plantilla[,4])
rgl_add_axes(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], show.bbox = T)
aspect3d(1,1,1)
plot3d(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], col=plantilla[,4])
library(tree)
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
library(tree)
install.packages("tree")
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
library(tree)
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
summary(tree.iris)
plot(tree.iris)
text(tree.iris, pretty=0)
tree.iris
# Dividir en training y test
set.seed (2)
train=sample (1:nrow(iris), 100)
iris.test=iris [-train ,]
# Construyo el arbol sobre el conjunto de entrenamiento
tree.iris =tree(Species~. ,iris ,subset =train )
# Aplico el arbol sobre el conjunto de test
tree.pred =predict (tree.iris ,iris.test ,type ="class")
# Visualizo la matriz de confusion
table(tree.pred , iris.test[,5])
# Podar el arbol usando cv
set.seed (3)
cv.iris = cv.tree(tree.iris ,FUN=prune.misclass )
names(cv.iris )
cv.iris
# Pintamos el error
par(mfrow =c(1,2))
plot(cv.iris$size ,cv.iris$dev ,type="b")
plot(cv.iris$k ,cv.iris$dev ,type="b")
# Ahora podamos el arbol con prune.misclass
prune.iris =prune.misclass (tree.iris ,best =3)
par(mfrow =c(1,1))
plot(prune.iris)
text(prune.iris ,pretty =0)
# Como se comportara este arbol en su capacidad de prediccion
tree.pred=predict (prune.iris , iris.test ,type="class")
table(tree.pred ,iris.test[,5])
# Ahora podemos modificar el tamanio del arbol modificando best
prune.iris =prune.misclass (tree.iris ,best =4)
plot(prune.iris)
text(prune.iris ,pretty =0)
tree.pred=predict (prune.iris , iris.test ,type="class")
table(tree.pred ,iris.test[,5])
# Random Forest
library (randomForest)
set.seed (1)
bag.iris = randomForest(Species~., data=iris, subset=train)
bag.iris
yhat.bag = predict (bag.iris ,newdata =iris.test)
yhat.bag
# Construyo una funcion para calcular el acierto a partir del RandomForest
acierto <- function(bag.datos){
return (sum (sapply(1:length(bag.datos$y), function(x){
if (is.na(bag.datos$predicted[x])){
0
}
else if (as.numeric(bag.datos$y[x])==as.numeric(bag.datos$predicted[x])){
1
}
else{
0
}
}))/length(bag.datos$y))
}
resul = as.data.frame(cbind(predicted = yhat.bag, y=iris.test[,5]))
acierto(resul)
# Fijando el numero de arboles
bag.iris = randomForest(Species~.,data=iris ,subset =train , ntree=25)
bag.iris
acierto(bag.iris)
bag.func = randomForest(formula,data=datos,ntree=num_trees)
bag.func = randomForest(formula,data=datos,subset=train,ntree=num_trees)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
bag.func = randomForest(formula,data=datos,subset=train,ntree=num_trees)
acierto(bag.func)
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
}
Graphical_RF(iris,Species~.,100)
vec
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
vec
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
plot(1:num_trees,vec)
}
Graphical_RF(iris,Species~.,100)
lines()
lines(vec)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
plot(1:num_trees,vec)
lines(vec)
}
Graphical_RF(iris,Species~.,100)
summary(iris)
summary(Auto)
Auto
Autos
summary(Autos)
library(ISLR)
summary(Autos)
summary(Auto)
dim(Auto)
dim(iris)
set.seed (2)
train=sample (1:nrow(Auto), 300)
datos = Auto
Graphical_RF(datos,origin~.-name,100)
train=sample (1:nrow(iris), 100)
set.seed (2)
train=sample (1:nrow(iris), 100)
install.packages("bnlearn")
library(bnlearn)
dag <- empty.graph(nodes = c("A", "S", "E", "O",
"R", "T"))
dag
dag <- set.arc(dag, from = "A", to = "E")
dag
dag <- set.arc(dag, from = "S", to = "E") #S-E
dag <- set.arc(dag, from = "E", to = "O") #E-O
dag <- set.arc(dag, from = "E", to = "R") #E-R
dag <- set.arc(dag, from = "O", to = "T") #O-T
dag <- set.arc(dag, from = "R", to = "T") #R-T
dag
modelstring(dag)
modelstring(dag)= "[A][S][E|A:S][O|E][R|E][T|O:R]"
modelstring(dag)
dag3 <- model2network("[A][S][E|A:S][O|E][R|E][T|O:R]")
modelstring(dag3)
all.equal(dag,dag3)
nodes(dag)
archs(dag)
arcs(dag)
dag2 <- empty.graph(nodes = c("A", "S", "E", "O", "R", "T"))
arc.set <- matrix(c("A", "E", "S", "E",  "E", "O",  "E", "R", "O", "T", "R", "T"),
byrow = TRUE, ncol = 2, dimnames = list(NULL, c("from", "to")))
all.equal(dag,dag2)
arcs(dag2) <- arc.set
all.equal(dag,dag2)
try(set.arc(dag, from="T", to="E"))
plot(dag)
source("http://bioconductor.org/biocLite.R")
biocLite("Rgraphviz")
graphviz.plot(dag)
A.st <- c("young", "adult", "old")
S.st <- c("M", "F")
E.st <- c("high", "uni")
O.st <- c("emp", "self")
R.st <- c("small", "big")
T.st <- c("car", "train", "other")
A.prob <- array(c(0.30, 0.50, 0.20), dim=3, dimnames = list(A = A.st))
A.prob
S.prob <- array(c(0.60, 0.40), dim=2, dimnames = list(S = S.st))
S.prob
O.prob <- array(c(0.96, 0.04, 0.92, 0.08), dim=c(2,2), dimnames = list(O = O.st, E = E.st))
O.prob
R.prob <- array(c(0.25, 0.75, 0.20, 0.80), dim=c(2,2), dimnames = list(R = R.st, E = E.st))
R.prob
R.prob <- matrix(c(0.25, 0.75, 0.20, 0.80), ncol = 2, dimnames = list(R = R.st, E = E.st))
E.prob <- array(c(0.75, 0.25, 0.72, 0.28, 0.88, 0.12, 0.64, 0.36, 0.70, 0.30, 0.90, 0.10), dim=c(2, 3, 2),
dimnames = list(E = E.st, A = A.st, S = S.st))
T.prob <- array(c(0.48, 0.42, 0.10, 0.56, 0.36, 0.08, 0.58, 0.24, 0.18, 0.70, 0.21, 0.09), dim=c(3, 2, 2),
dimnames = list(T = T.st, O = O.st, R = R.st))
cpt <- list(A=A.prob, S=S.prob, E=E.prob, O=O.prob, R=R.prob, T=T.prob)
bn <- custom.fit(dag,cpt)
nparams(bn)
arcs(bn)
bn$R
R.cpt <- coef(bn$R)
R.cpt
bn
dspe(dag, x= "S", y = "R")
dsep(dag, x= "S", y = "R")
dsep(da, x = "O", y = "R")
dsep(dag, x = "O", y = "R")
path(dag, from = "S", to = "R")
dsep(dag, x = "S", y = "R", z = "E")
dspe(dag, x="S", y="T", z=c("O", "R"))
dsep(dag, x="S", y="T", z=c("O", "R"))
dsep(dag, x="O", y="R", z="E")
dsep(dag, x="A", y="S")
dsep(dag, x="A", y="S", z="E")
>  >
source("http://bioconductor.org/biocLite.R")
biocLite(c("graph","RBGL","Rgraphviz"))
install.packages("gRain")
library(gRain)
junction <- compile(as.grain(bn))
querygrain(junction, nodes="T")$T
jsex <- setEvidence(junction, nodes="S", states="F")
querygrain(jsex, nodes="T")$T
jres <- setEvidences(junction, nodes="R", states="small")
jres <- setEvidence(junction, nodes="R", states="small")
querygrain(jres, nodes="T")$T
jedu <- setEvidence(junction, nodes="E", states="high")
SxT.cpt <- querygrain(jedu, nodes= c("S","T"), type = "joint")
SxT.cpt
querygrain(jedu, nodes = c("S", "T"), type = "marginal")
querygrain(jedu, nodes = c("S", "T"), type = "conditional")
dsep(bn, x="S", y="T", z="E")
cpquery(bn, event = (S=="M") & (T=="car"), evidence=(E=="high"))
cpquery(bn,event=(S=="M") & (T=="car"),evidence=(E=="high"),n=10^6)
cpquery(bn,event=(s=="M") & (T=="car"), evidence=list(E=="high"),method="lw")
cpquery(bn,event=(S=="M") & (T=="car"), evidence=list(E=="high"),method="lw")
cpquery(bn, event = (S == "M") & (T == "car"), evidence = list(E = "high"), method = "lw")
cpquery(bn, event = (S == "M") & (T == "car"), evidence = ((A == "young") & (E == "uni")) | (A == "adult"))
SxT <- cpdist(bn, nodes = c("S","T"), evidence = (E=="high"))
head(SxT)
prop.table(table(SxT))
survey <- read.table("survey.txt", header = TRUE)
setwd("~/Dropbox/zMaster/zRStudio/Master-en-Ciencia-De-Datos-e-Ingeniería-de-Computadores-2/3 Modelos Graficos Probabilisticos")
survey <- read.table("survey.txt", header = TRUE)
head(survey)
bn.mle <- bn.fit(dag, data=survey, method="mle")
prop.table(table(survey[,c("O","E")]),margin=2)
bn.mle$O
bn.bayes <- bn.fit(dag, data=survey, method="bayes",iss=10)
bn.bayes$O
bn.bayes <- bn.fit(dag, data=survey, method="bayes", iss=20)
bn.bayes$O
learned <- hc(survey)
modelstring(learned)
score(learned, data=survey,type="bic")
learned2 <- hc(survey, score="bde")
